# Bachelor Theses on Selfie

## Implementation and Application of a Parser for Boolector's Witness Format, University of Salzburg, Austria, 2020 ([PDF](https://github.com/cksystemsteaching/selfie/releases/download/bachelor_thesis_siller/bachelor_thesis_siller.pdf), [Release](https://github.com/cksystemsteaching/selfie/releases/tag/bachelor_thesis_siller))

In this bachelor thesis, a parser for Boolector’s witness format is introduced, which enables automated input validation. The toolchain takes a C* file containing read calls as input and generates a Btor2 model of it, using Selfie’s model generator. The resulting model is then fed to the Boolector-based bounded model checker BtorMC. By using SMT-solving, BtorMC is able to find error states in the model within a maximum number of executed instructions. In case an error state is found, BtorMC generates a witness. This witness is parsed in order to extract the input string that causes the C* program to run into the error. To validate that the extracted string indeed triggers an error, it is fed to the C* program while running it on Mipster. If the input string was generated correctly, Mipster runs into the predicted error. In addition to the parser, this thesis provides background information on all technologies used and the concepts they are based on.

## Selfie - RISC-V to x86-64 Binary Translation by Alexander Kollert, University of Salzburg, Austria, 2020 ([PDF](https://github.com/cksystemsteaching/selfie/releases/download/bachelor_thesis_kollert/bachelor_thesis_kollert.pdf), [Release](https://github.com/cksystemsteaching/selfie/releases/tag/bachelor_thesis_kollert))

In this work I present an implementation of a binary translator that statically translates RISC-V machine code produced by starc into x86-64 machine code. The requirements are that the binary translator should be able to translate Selfie itself and the usage of a minimal subset of x86-64 instructions. As it is in the nature of Selfie the implementation should also be as minimal as possible. There are a few challenges to overcome to make this work. First the x86-64 ISA (Instruction Set Architecture) is an variable length instruction set which makes calculation of target addresses of jump instructions more difficult. Further the x86-64 instruction set mostly consists of two-operator instructions and even some single-operator instructions in contrast to three-operator instructions in RISC-V. And last but not least we will see that for some RISC-V instructions it is not possible to make an translation entirely without context. The result is a binary translator that is able to generate an x86-64 selfie binary with functioning self-compilation in x86-64. The difference with the translated binary is that there is no longer a need to link against a library, since it uses its own implemantations for the library routines.

## A Hybrid Symbolic Execution and Bounded Model Checking Engine in Selfie by Christian Edelmayer, University of Salzburg, Austria, 2019 ([PDF](https://github.com/cksystemsteaching/selfie/releases/download/bachelor_thesis_edelmayer/bachelor_thesis_edelmayer.pdf), [Release](https://github.com/cksystemsteaching/selfie/releases/tag/bachelor_thesis_edelmayer))

In a world dependent on software, it is of the utmost importance to ensure the correctness of that software. For this reason, software needs to be analyzed. In this thesis, the software analysis methods called symbolic execution and bounded model checking are explained in detail. Furthermore, a hybrid symbolic execution and bounded model checking engine was implemented in Selfie. It is outlined thoroughly how the symbolic execution engine was extended into the hybrid engine. The main challenge was to implement the merging of paths which corresponds to bounded model checking. Our experiments show that symbolic execution produces formulas which can be solved more easily at the cost of a slower translation time. Exactly the opposite is true for bounded model checking. In other words, both methods have their advantages and disadvantages.

## Symbolic Execution with Selfie --- Logics by Sara Seidl, University of Salzburg, Austria, 2019 ([PDF](https://github.com/cksystemsteaching/selfie/blob/master/theses/bachelor_thesis_seidl.pdf))

State-of-the-art symbolic execution engines are based on computationally expensive SMT solvers that may not perform well on large programs. There is, however, a trade-off between performance and completeness. Restricting completeness such that a solver works only on a subset of all possible programs may nevertheless allow us to make the solver faster and scale to larger programs. The solver we developed is based on interval modulo arithmetic rather than bit-vector logics used by many other symbolic execution engines. Further, constraint solving is not achieved by solving formulas but entirely through execution of code. It is interval modulo arithmetic in combination with this constraint solving technique that allows us to solve constraints fast. The solver is complete as long as the set of concrete values a symbolic value represents can be expressed as an interval. The challenge is to be able to detect if the solver is still complete during symbolic execution of a given program. Moreover, the subset of programs for which a solver may be complete during symbolic execution needs to be sufficiently interesting. For us, this is the case if non-trivial parts of our selfie system are part of that subset.

## Symbolic Execution with Selfie --- Systems by Simon Bauer, University of Salzburg, Austria, 2018 ([PDF](https://github.com/cksystemsteaching/selfie/blob/master/theses/bachelor_thesis_bauer.pdf))

This thesis presents a simple symbolic execution engine, which was integrated into the SELFIE project, an educational platform already containing a self-referential compiler, emulator and hypervisor. The idea behind symbolic execution is to provide a program with arbitrary symbolic - rather than concrete - input, which allows the symbolic engine to efficiently explore all control flow paths of the program. Our engine differs from state-of-the-art solutions as it does not utilise a constraint solver and is therefore faster than other tools. As a consequence, the engine is only able to handle a subset of all possible programs though. The thesis gives an overview over the engines building parts and their differences as well as similarities compared to other symbolic tools.

## Symbolic Execution with Selfie --- Arithmetics by Manuel Widmoser, University of Salzburg, Austria, 2018 ([PDF](https://github.com/cksystemsteaching/selfie/blob/master/theses/bachelor_thesis_widmoser.pdf))

Modern symbolic execution engines are lacking in scalability and performance due to computationally expensive Satisfiability Modulo Theory (SMT) solvers. Such engines attempt to execute for all possible inputs in order to find vulnerabilities in an elegant way. Within an entirely self-contained system, we developed a symbolic execution engine on machine code level without using a theory solver. This becomes achievable by interval arithmetic and the ability of backtracking code execution. However, there is a trade-off between performance and completeness. This thesis mainly describes the data structure behind the engine as well as symbolic code execution using interval arithmetic. Despite some reasonable limitations the subset of programs, which can be executed by the engine, keeps sufficiently interesting. In return, soundness and simplicity maintain.

## Porting Selfie to RISC-V: State-of-the-Art ISA Support by Simone Oblasser, University of Salzburg, Austria, 2017 ([PDF](https://github.com/cksystemsteaching/selfie/blob/master/theses/bachelor_thesis_oblasser.pdf))

The following thesis describes a newly developed alternative version of Selfie, a self-referential platform containing a compiler, an emulator and a hypervisor for teaching computer systems. Instead of MIPS32 code, this version supports a minimal subset of RISC-V (RV32I plus "M" standard extension), an open-source ISA developed at University of California, Berkeley. The port to this different architecture included the adaption of all major parts of Selfie, especially of the compiler and emulator. The key changes made involved register usage, encoding and decoding of the new instruction formats, and handling of immediate values. The resulting platform still fulfills all the self-referentiality requirements the original project did. Furthermore, the new support for RISC-V instructions paved the way for an additional project to make binaries generated by Selfie (and, in turn, Selfie itself) executable on official RISC-V emulators and hardware chips.

## Porting Selfie to RISC-V: Native Toolchain Support by Christian Barthel, University of Salzburg, Austria, 2017 ([PDF](https://github.com/cksystemsteaching/selfie/blob/master/theses/bachelor_thesis_barthel.pdf))

The goal of this project is to provide an educational system that consists of a simple self-compiling compiler, a self-executing instruction set emulator and a minimal self-hosting hypervisor, based on the RISC-V instruction set. Its main purpose is to introduce students to principal systems engineering techniques and teach students about computer architecture, compilers and operating systems. Everything is designed to be self-referential, to allow students to discover the intrinsics of system code which is known to be a big challenge. During this project, I worked on adding the ELF32 binary format to the compiler and emulator and making the overall system compatible with the RISC-V environment. Beside adding the ELF header, this involved also code adaption and synchronization with the operating system interface provided by the pk kernel. The work bridges the gap between the existing toolchain that is based on an artificial RAW binary format, and the RISCV32 GNU toolchain which is widely used on various operating systems and computer platforms. It is now possible to run binaries generated by starc on top of the RISC-V instruction set reference implementation spike. Furthermore, it should be simple to run binaries directly on RISC-V microprocessors.
