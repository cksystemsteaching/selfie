# Bachelor Theses on Selfie


## Conservative Garbage Collection in Kernel and Mutator Space by Gregor Bachinger, University of Salzburg, Austria, 2020 ([PDF](https://github.com/cksystemsteaching/selfie/releases/download/bachelor_thesis_bachinger/bachelor_thesis_bachinger.pdf), [Release](https://github.com/cksystemsteaching/selfie/releases/tag/bachelor_thesis_bachinger))

Compiling C or any similar language into binaries only provides support for explicit, manual memory management. To combat these issues, garbage collectors have been employed which handle memory management automatically. Since garbage collectors are specialized and use a lot of assumptions about their target environments, different algorithms are usually used for collectors in and outside of the mutator's address space. We have designed and implemented a conservative garbage collector that can run either in kernel or mutator space, or even in both at the same time. Running our collector in kernel and mutator space at the same time shows, that the collector is able to collect its own garbage. Furthermore, our experiments show the runtime/space tradeoff between collector invoke frequency and running it on machine and application level.

## Generating Path Conditions for Bounded Model Checking of RISC-V Code in Selfie by Sebastian Landl, University of Salzburg, Austria, 2020 ([PDF](https://github.com/cksystemsteaching/selfie/releases/download/bachelor_thesis_landl/bachelor_thesis_landl.pdf), [Release](https://github.com/cksystemsteaching/selfie/releases/tag/bachelor_thesis_landl))

Given a 64-bit RISC-V binary we compute a single logical formula that is satisfiable if and only if there exists input to the code such that there is a division by zero, invalid memory access, or a non-zero exit code when executing no more than a given maximum number of any type of instructions and a given maximum number of branch instructions. We do this by creating a logical formula, which is satisfiable if and only if a given instruction is reachable, called a path condition for each possible path of the program. This is commonly known as symbolic execution. We then merge different path conditions as soon as there is an instruction which can be reached from different paths in the control flow. Creating a single formula for all paths mimics bounded model checking. This is done by checking after every single executed instruction, whether there is another path condition which can be merged with the one we just extended by executing one instruction. Two path conditions are mergeable if they describe the reachability of the very same instruction and if the call stacks of their respective execution paths are the same. For that reason the call stacks of all paths are stored in a global tree structure. To determine which instruction shall be executed next, i.e. which path should be explored further, the path which has the biggest call stack and describes the reachability of the instruction with the lowest program counter is chosen, so that a merge always happens as soon as possible and no possible merge location is ever missed. The time it takes to schedule the next path is linear in the number of paths that are being explored. The size of the generated formula is in O(a &sdot; 2<sup>b</sup>) where a is the maximum number of instructions executed on each path and b &le; a is the maximum number of branch instructions for which both branches are considered.

## Implementation and Application of a Parser for Boolector's Witness Format by Christoph Siller, University of Salzburg, Austria, 2020 ([PDF](https://github.com/cksystemsteaching/selfie/releases/download/bachelor_thesis_siller/bachelor_thesis_siller.pdf), [Release](https://github.com/cksystemsteaching/selfie/releases/tag/bachelor_thesis_siller))

In this bachelor thesis, a parser for Boolector’s witness format is introduced, which enables automated input validation. The toolchain takes a C* file containing read calls as input and generates a Btor2 model of it, using Selfie’s model generator. The resulting model is then fed to the Boolector-based bounded model checker BtorMC. By using SMT-solving, BtorMC is able to find error states in the model within a maximum number of executed instructions. In case an error state is found, BtorMC generates a witness. This witness is parsed in order to extract the input string that causes the C* program to run into the error. To validate that the extracted string indeed triggers an error, it is fed to the C* program while running it on Mipster. If the input string was generated correctly, Mipster runs into the predicted error. In addition to the parser, this thesis provides background information on all technologies used and the concepts they are based on.

## Selfie - RISC-V to x86-64 Binary Translation by Alexander Kollert, University of Salzburg, Austria, 2020 ([PDF](https://github.com/cksystemsteaching/selfie/releases/download/bachelor_thesis_kollert/bachelor_thesis_kollert.pdf), [Release](https://github.com/cksystemsteaching/selfie/releases/tag/bachelor_thesis_kollert))

In this work I present an implementation of a binary translator that statically translates RISC-V machine code produced by starc into x86-64 machine code. The requirements are that the binary translator should be able to translate Selfie itself and the usage of a minimal subset of x86-64 instructions. As it is in the nature of Selfie the implementation should also be as minimal as possible. There are a few challenges to overcome to make this work. First the x86-64 ISA (Instruction Set Architecture) is an variable length instruction set which makes calculation of target addresses of jump instructions more difficult. Further the x86-64 instruction set mostly consists of two-operator instructions and even some single-operator instructions in contrast to three-operator instructions in RISC-V. And last but not least we will see that for some RISC-V instructions it is not possible to make an translation entirely without context. The result is a binary translator that is able to generate an x86-64 selfie binary with functioning self-compilation in x86-64. The difference with the translated binary is that there is no longer a need to link against a library, since it uses its own implemantations for the library routines.

## A Hybrid Symbolic Execution and Bounded Model Checking Engine in Selfie by Christian Edelmayer, University of Salzburg, Austria, 2019 ([PDF](https://github.com/cksystemsteaching/selfie/releases/download/bachelor_thesis_edelmayer/bachelor_thesis_edelmayer.pdf), [Release](https://github.com/cksystemsteaching/selfie/releases/tag/bachelor_thesis_edelmayer))

In a world dependent on software, it is of the utmost importance to ensure the correctness of that software. For this reason, software needs to be analyzed. In this thesis, the software analysis methods called symbolic execution and bounded model checking are explained in detail. Furthermore, a hybrid symbolic execution and bounded model checking engine was implemented in Selfie. It is outlined thoroughly how the symbolic execution engine was extended into the hybrid engine. The main challenge was to implement the merging of paths which corresponds to bounded model checking. Our experiments show that symbolic execution produces formulas which can be solved more easily at the cost of a slower translation time. Exactly the opposite is true for bounded model checking. In other words, both methods have their advantages and disadvantages.

## Symbolic Execution with Selfie --- Logics by Sara Seidl, University of Salzburg, Austria, 2019 ([PDF](https://github.com/cksystemsteaching/selfie/blob/master/theses/bachelor_thesis_seidl.pdf))

State-of-the-art symbolic execution engines are based on computationally expensive SMT solvers that may not perform well on large programs. There is, however, a trade-off between performance and completeness. Restricting completeness such that a solver works only on a subset of all possible programs may nevertheless allow us to make the solver faster and scale to larger programs. The solver we developed is based on interval modulo arithmetic rather than bit-vector logics used by many other symbolic execution engines. Further, constraint solving is not achieved by solving formulas but entirely through execution of code. It is interval modulo arithmetic in combination with this constraint solving technique that allows us to solve constraints fast. The solver is complete as long as the set of concrete values a symbolic value represents can be expressed as an interval. The challenge is to be able to detect if the solver is still complete during symbolic execution of a given program. Moreover, the subset of programs for which a solver may be complete during symbolic execution needs to be sufficiently interesting. For us, this is the case if non-trivial parts of our selfie system are part of that subset.

## Symbolic Execution with Selfie --- Systems by Simon Bauer, University of Salzburg, Austria, 2018 ([PDF](https://github.com/cksystemsteaching/selfie/blob/master/theses/bachelor_thesis_bauer.pdf))

This thesis presents a simple symbolic execution engine, which was integrated into the SELFIE project, an educational platform already containing a self-referential compiler, emulator and hypervisor. The idea behind symbolic execution is to provide a program with arbitrary symbolic - rather than concrete - input, which allows the symbolic engine to efficiently explore all control flow paths of the program. Our engine differs from state-of-the-art solutions as it does not utilise a constraint solver and is therefore faster than other tools. As a consequence, the engine is only able to handle a subset of all possible programs though. The thesis gives an overview over the engines building parts and their differences as well as similarities compared to other symbolic tools.

## Symbolic Execution with Selfie --- Arithmetics by Manuel Widmoser, University of Salzburg, Austria, 2018 ([PDF](https://github.com/cksystemsteaching/selfie/blob/master/theses/bachelor_thesis_widmoser.pdf))

Modern symbolic execution engines are lacking in scalability and performance due to computationally expensive Satisfiability Modulo Theory (SMT) solvers. Such engines attempt to execute for all possible inputs in order to find vulnerabilities in an elegant way. Within an entirely self-contained system, we developed a symbolic execution engine on machine code level without using a theory solver. This becomes achievable by interval arithmetic and the ability of backtracking code execution. However, there is a trade-off between performance and completeness. This thesis mainly describes the data structure behind the engine as well as symbolic code execution using interval arithmetic. Despite some reasonable limitations the subset of programs, which can be executed by the engine, keeps sufficiently interesting. In return, soundness and simplicity maintain.

## Porting Selfie to RISC-V: State-of-the-Art ISA Support by Simone Oblasser, University of Salzburg, Austria, 2017 ([PDF](https://github.com/cksystemsteaching/selfie/blob/master/theses/bachelor_thesis_oblasser.pdf))

The following thesis describes a newly developed alternative version of Selfie, a self-referential platform containing a compiler, an emulator and a hypervisor for teaching computer systems. Instead of MIPS32 code, this version supports a minimal subset of RISC-V (RV32I plus "M" standard extension), an open-source ISA developed at University of California, Berkeley. The port to this different architecture included the adaption of all major parts of Selfie, especially of the compiler and emulator. The key changes made involved register usage, encoding and decoding of the new instruction formats, and handling of immediate values. The resulting platform still fulfills all the self-referentiality requirements the original project did. Furthermore, the new support for RISC-V instructions paved the way for an additional project to make binaries generated by Selfie (and, in turn, Selfie itself) executable on official RISC-V emulators and hardware chips.

## Porting Selfie to RISC-V: Native Toolchain Support by Christian Barthel, University of Salzburg, Austria, 2017 ([PDF](https://github.com/cksystemsteaching/selfie/blob/master/theses/bachelor_thesis_barthel.pdf))

The goal of this project is to provide an educational system that consists of a simple self-compiling compiler, a self-executing instruction set emulator and a minimal self-hosting hypervisor, based on the RISC-V instruction set. Its main purpose is to introduce students to principal systems engineering techniques and teach students about computer architecture, compilers and operating systems. Everything is designed to be self-referential, to allow students to discover the intrinsics of system code which is known to be a big challenge. During this project, I worked on adding the ELF32 binary format to the compiler and emulator and making the overall system compatible with the RISC-V environment. Beside adding the ELF header, this involved also code adaption and synchronization with the operating system interface provided by the pk kernel. The work bridges the gap between the existing toolchain that is based on an artificial RAW binary format, and the RISCV32 GNU toolchain which is widely used on various operating systems and computer platforms. It is now possible to run binaries generated by starc on top of the RISC-V instruction set reference implementation spike. Furthermore, it should be simple to run binaries directly on RISC-V microprocessors.
